---
title: "India GDP Project"
author: "Jay & Parker"
date: "2024-02-09"
output: html_document
---
# read in the India GDP File
```{r}
library(readxl)
IndiaGDP <- read_excel("India_GDP.xlsx", sheet = "Sheet1")

# plot the India GDP
# names(IndiaGDP)[1] <- "Year"
# names(IndiaGDP)[2] <- "GDP"
IndiaGDP_ts <-
  ts(
    IndiaGDP$GDP,
    start = c(1980),
    end = c(2023),
    frequency = 1
  )
t

# plot India GDP
plot(IndiaGDP_ts, type = "l", col = "blue")
```

# Detrend The Model
```{r}
library(forecast)

# got rid of the forecasts 2024-2028 (5 years)
IndiaGDP <- IndiaGDP[-c(45, 46, 47, 48, 49),]

# clear evidence of cycles
# detrend for cyclical too
# make a t variable to track the row number of the IndiaGDP data frame
t <- 1:nrow(IndiaGDP)
IndiaGDP$t <- t
cyc1 <- sin((2 * pi * t) / 44)
cyc2 <- cos((2 * pi * t) / 44)
# a half cycle is about 22 years, so the whole cycle would be 44 years
# determined 22 after looking at the residuals
```


## Data Partitioning
```{r}
# partition the data - 41 years training, 3 years validation
train.ts <- window(IndiaGDP_ts, start = c(1980), end = c(2018))
valid.ts <- window(IndiaGDP_ts, start = c(2019), end = c(2023))
# we wanted COVID to be present in both training and validation sets
# justify why you choose your training period
# it must be representative of the circumstances of the forecast horizon

# detrend on train
DTGDP <- tslm(train.ts ~ I(trend ^ 2) + cyc2[1:39])
summary(DTGDP)

# detrend on cubic and cycle2
DTGDP_cubic_cyc2 <- tslm(train.ts ~ I(trend ^ 3) + cyc2[1:39])
summary(DTGDP_cubic_cyc2)

# detrend for linear
DTGDP_linear <- tslm(train.ts ~ trend)
summary(DTGDP_linear) # R^2 = 0.8266 and ***

# detrend for quadratic
DTGDP_quad <- tslm(train.ts ~ I(trend ^ 2))
summary(DTGDP_quad) # R^2 = 0.9566 and ***

# detrend for cubic
DTGDP_cubic <- tslm(train.ts ~ I(trend ^ 3))
summary(DTGDP_cubic) # R^2 = 0.9824 and ***

# detrend for cycles
DTGDP_cyc <- tslm(train.ts ~ cyc1[1:39] + cyc2[1:39])
summary(DTGDP_cyc) # R^2 = 0.7323 and both cycles are ***

# detrend for cubic and linear
DTGDP_cubic_linear <- tslm(train.ts ~ I(trend ^ 3) + trend)
summary(DTGDP_cubic_linear) # R^2 = 0.9824. Cubic is *** and linear is not sig

# detrend for cubic and quadratic
DTGDP_cubic_quad <- tslm(train.ts ~ I(trend ^ 3) + I(trend ^ 2))
summary(DTGDP_cubic_quad) # R^2 = 0.9824. Cubic is `***` and quadratic is not sig

# detrend for cubic and cycles
DTGDP_cubic_cyc <- tslm(train.ts ~ I(trend ^ 3) + cyc1[1:39] + cyc2[1:39])
summary(DTGDP_cubic_cyc) # R^2 = 0.985. Cubic is *** and both cycles are *

# most parsimonious is just cubic

# plot residuals for just cubic
plot(DTGDP_cubic$residuals, type = "l")

# plot residuals for cubic and cycles
plot(DTGDP_cubic_cyc$residuals, type = "l")

# cubic is better

# test for autocorrelation
library(car)
# autocorrelation
durbinWatsonTest(DTGDP)
# lag Autocorrelation D-W Statistic p-value
#   1       0.5778103     0.8111599   0.014
# Alternative hypothesis: rho != 0
# there is autocorrelation

# store residuals - MAKE SURE THIS IS USING THE BEST MODEL
DTGDP_cubic_resids <- DTGDP$residuals

# Check ACF PACF of residuals
par(mfrow = c(1, 2))
A = Acf(DTGDP_cubic_resids, main = "ACF of Residuals")
A
B = Pacf(DTGDP_cubic_resids, main = "PACF of Residuals")
B

# We have an AR(1) component, an MA(1) component, and a MA(8) component
ARMA1_DT <- Arima(DTGDP_cubic_resids, order = c(1, 0, 0))
summary(ARMA1_DT)

# check for significance
0.5825 / 0.1284
# greater than 2 so it is significant

# get and plot the residuals
ARMA1_resids <- ARMA1_DT$residuals
plot(ARMA1_resids, type = "l")

par(mfrow = c(1, 2))
A = Acf(ARMA1_resids, main = "ACF of Residuals")
A
B = Pacf(ARMA1_resids, main = "PACF of Residuals")
B

# All components have been removed
# Removing AR(1) took care of the MA(1) and MA(8)

# We can now forecast
```

Neural Network
```{r}
library(neuralnet)
library(dplyr)
library(caret)

setup1 <- nnetar(IndiaGDP_ts[1:39],
                 p = 12,
                 repeats = 20,
                 lambda = "auto")

#Once the model is set up, we forecast. PI - prediction intervals
Fcast <- forecast(setup1, PI = TRUE, h = 5)
#Show results
autoplot(Fcast)
```


Prediction for 2024
```{r}
gdp2023.residual <-
  window(DTGDP_cubic_resids, start = c(2018), end = c(2018))

plugin.forecast <-
  gdp2023.residual * ARMA1_DT$coef[1] + ARMA1_DT$coef[2]

print(plugin.forecast)
```

```{r}
# ENSURE THE DENOMINATOR I.E. 40 or whatever matches what is up top
gdp2023.residual <-
  window(DTGDP_cubic_resids, start = c(1980), end = c(2018))

t <- length(gdp2023.residual) + 1

forecasted.value <- DTGDP$coefficients[1] + DTGDP$coefficients[2] * (t ^ 2) + DTGDP$coefficients[3] * cos((2 * pi * t) / 44)

forecasted.value
```


```{r}
plugin.forecast + forecasted.value
```


